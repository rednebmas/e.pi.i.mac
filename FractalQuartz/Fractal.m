//
//  Window.m
//  FractalQuartz
//
//  Created by Sam Bender on 9/23/15.
//  Copyright © 2015 Sam Bender. All rights reserved.
//

#import "Fractal.h"
// This include pulls in everything you need to develop with OpenCL in OS X.
#include <OpenCL/opencl.h>
// Include the header file generated by Xcode.  This header file contains the
//  kernel block declaration.                                             // 1
#include "iteratekernel.cl.h"

typedef struct DoublePoint
{
    double a;
    double b;
} DoublePoint;

@interface Fractal()
{
    DoublePoint *pointGrid;
    double *pointGridD;
    double *z0D;
    DoublePoint *z0;
    ushort *iterationCount;
    WindowEdges windowEdges;
    WindowSize resolution;
    int numberOfPixels;
}

@end

@implementation Fractal

- (id) initWithWindowEdges:(WindowEdges)_windowEdges outputResolution:(WindowSize)_resolution
{
    self = [super init];
    if (self)
    {
        [self setWindowEdges:_windowEdges outputResolution:_resolution];
        _iterations = 254;
    }
    return self;
}

- (void) setWindowEdges:(WindowEdges)_windowEdges outputResolution:(WindowSize)_resolution
{
    windowEdges = _windowEdges;
    resolution = _resolution;
    numberOfPixels = resolution.width * resolution.height;
    
    pointGrid = malloc(sizeof(DoublePoint) * resolution.width * resolution.height);
    z0 = malloc(sizeof(DoublePoint) * resolution.width * resolution.height);
    
    // multiply size by two because each point is a coordinate, a + bi
    pointGridD = malloc(sizeof(double) * numberOfPixels * 2);
    z0D = malloc(sizeof(double) * numberOfPixels * 2);
    
    iterationCount = malloc(sizeof(ushort) * resolution.width * resolution.height);
    
    double realIncrement = fabs(windowEdges.right - windowEdges.left) / resolution.width;
    double imaginaryIncrement = fabs(windowEdges.top - windowEdges.bottom) / resolution.height;
    
    double currentRealValue = windowEdges.left;
    double currentImaginaryValue = windowEdges.top;
    
    int pos = 0;
    
    for (int y = 0; y < resolution.height; y++)
    {
        for (int x = 0; x < resolution.width; x++)
        {
            DoublePoint point;
            point.a = currentRealValue;
            point.b = currentImaginaryValue;
            
            DoublePoint z0Point;
            z0Point.a = currentRealValue;
            z0Point.b = currentImaginaryValue;
            
            pos = x + y * resolution.width;
            
            pointGrid[pos] = point;
            z0[pos] = z0Point;
            
            pointGridD[pos * 2] = currentRealValue;
            pointGridD[pos * 2 + 1] = currentImaginaryValue;
            z0D[pos * 2] = currentRealValue;
            z0D[pos * 2 + 1] = currentImaginaryValue;
            
            iterationCount[pos] = 0;
            
            currentRealValue += realIncrement;
        }
        
        currentRealValue = windowEdges.left;
        currentImaginaryValue -= imaginaryIncrement;
    }
    
    NSAssert(pointGridD[0] == windowEdges.left, @"");
    NSAssert(pointGridD[1] == windowEdges.top, @"");
//    NSAssert(pointGridD[(resolution.width - 1) * 2] == windowEdges.right,
//             @"double window edges incorrect: %f", pointGridD[(resolution.width - 1) * 2]);
    
    NSAssert(pointGrid[resolution.width].a == windowEdges.left, @"");
    NSAssert(pointGrid[resolution.width-1].a < windowEdges.right + (1.1 * realIncrement)
             && pointGrid[resolution.width-1].a > windowEdges.right - (1.1* realIncrement),
             @"Should be: %f, is: %f", windowEdges.right, pointGrid[resolution.width-1].a);
    
    NSAssert(pointGrid[resolution.width-1].b == windowEdges.top, @"");
    NSAssert(pointGrid[resolution.height * (resolution.width - 1)].b < windowEdges.bottom + (1.1 * imaginaryIncrement)
             && pointGrid[resolution.height * (resolution.width - 1)].b > windowEdges.bottom - (1.1 * imaginaryIncrement),
             @"Should be: %f, is: %f", windowEdges.bottom, pointGrid[resolution.height * (resolution.width - 1)].b);
}



- (void) run
{
    clock_t start = clock();

    /*
    int pos;
    DoublePoint newPoint;
    for (int y = 0; y < resolution.height; y++)
    {
        for (int x = 0; x < resolution.width; x++)
        {
            pos = x + y * resolution.width;
            DoublePoint *currentPoint = &pointGrid[pos];
            
            for (int i = 0; i < _iterations; i++)
            {
                if (currentPoint->a > 2 || currentPoint->b > 2)
                    break;
                
                newPoint.a = (currentPoint->a * currentPoint->a)
                - (currentPoint->b * currentPoint->b)
                + z0[pos].a;
                newPoint.b = 2 * currentPoint->b * currentPoint->a
                + z0[pos].b;
                
                pointGrid[pos] = newPoint;
                iterationCount[pos] += 1;
            }
        }
    } */
    
    
    int i;
    char name[128];
    
    // First, try to obtain a dispatch queue that can send work to the
    // GPU in our system.                                             // 2
    dispatch_queue_t queue =
    gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);
    
    // In the event that our system does NOT have an OpenCL-compatible GPU,
    // we can use the OpenCL CPU compute device instead.
    if (queue == NULL) {
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }
    
    // This is not required, but let's print out the name of the device
    // we are using to do work.  We could use the same function,
    // clGetDeviceInfo, to obtain all manner of information about the device.
    cl_device_id gpu = gcl_get_device_id_with_dispatch_queue(queue);
    clGetDeviceInfo(gpu, CL_DEVICE_NAME, 128, name, NULL);
    fprintf(stdout, "Created a dispatch queue using the %s\n", name);
    
    // The test kernel takes two parameters: an input double array and an
    // output double array.  We can't send the application's buffers above, since
    // our CL device operates on its own memory space.  Therefore, we allocate
    // OpenCL memory for doing the work.  Notice that for the input array,
    // we specify CL_MEM_COPY_HOST_PTR and provide the fake input data we
    // created above.  This tells OpenCL to copy the data into its memory
    // space before it executes the kernel.                               // 3
    void* mem_in  = gcl_malloc(sizeof(cl_double) * numberOfPixels * 2, pointGridD,
                               CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    void* mem_in_2  = gcl_malloc(sizeof(cl_double) * numberOfPixels * 2, z0D,
                               CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    // The output array is not initalized; we're going to fill it up when
    // we execute our kernel.                                             // 4
    void* mem_out =
    gcl_malloc(sizeof(cl_ushort) * numberOfPixels, NULL, CL_MEM_WRITE_ONLY);
    
    // Dispatch the kernel block using one of the dispatch_ commands and the
    // queue created earlier.                                            // 5
    
    dispatch_sync(queue, ^{
        // Although we could pass NULL as the workgroup size, which would tell
        // OpenCL to pick the one it thinks is best, we can also ask
        // OpenCL for the suggested size, and pass it ourselves.
        size_t wgs;
        gcl_get_kernel_block_workgroup_info((__bridge void * _Nonnull)(iterate_kernel),
                                            CL_KERNEL_WORK_GROUP_SIZE,
                                            sizeof(wgs), &wgs, NULL);
        
        // The N-Dimensional Range over which we'd like to execute our
        // kernel.  In this case, we're operating on a 1D buffer, so
        // it makes sense that the range is 1D.
        cl_ndrange range = {                                              // 6
            1,                     // The number of dimensions to use.
            
            {0, 0, 0},             // The offset in each dimension.  To specify
            // that all the data is processed, this is 0
            // in the test case.                   // 7
            
            {numberOfPixels, 0, 0},    // The global range—this is how many items
            // IN TOTAL in each dimension you want to
            // process.
            
            {wgs, 0, 0}            // The local size of each workgroup.  This
            // determines the number of work items per
            // workgroup.  It indirectly affects the
            // number of workgroups, since the global
            // size / local size yields the number of
            // workgroups.  In this test case, there are
            // NUM_VALUE / wgs workgroups.
        };
        // Calling the kernel is easy; simply call it like a function,
        // passing the ndrange as the first parameter, followed by the expected
        // kernel parameters.  Note that we case the 'void*' here to the
        // expected OpenCL types.  Remember, a 'double' in the
        // kernel, is a 'cl_double' from the application's perspective.   // 8
        
        iterate_kernel(&range,(cl_double*)mem_in, (cl_double*)mem_in_2, (cl_ushort*)mem_out);
        
        // Getting data out of the device's memory space is also easy;
        // use gcl_memcpy.  In this case, gcl_memcpy takes the output
        // computed by the kernel and copies it over to the
        // application's memory space.                                   // 9
        
        gcl_memcpy(iterationCount, mem_out, sizeof(cl_ushort) * numberOfPixels);
        
        clock_t diff = clock() - start;
        
        int msec = diff * 1000 / CLOCKS_PER_SEC;
        printf("Time taken %d seconds %d milliseconds\nk", msec/1000, msec%1000);
    });

    // Don't forget to free up the CL device's memory when you're done. // 10
    gcl_free(mem_in);
    gcl_free(mem_in_2);
    gcl_free(mem_out);
    
    // And the same goes for system memory, as usual.
//    free(test_in);
//    free(test_out);
}

- (RGBColor) rgbAtX:(int)x Y:(int)y
{
    int pos = x + y * resolution.width;
    
    RGBColor color;
    
    // iteration count values are between 0 and 255 for the moment
    color.red = iterationCount[pos];
    color.green = iterationCount[pos];
    color.blue = iterationCount[pos];
    
    return color;
}

- (void) dealloc
{
    free(pointGrid);
    free(z0);
    free(pointGridD);
    free(z0D);
    free(iterationCount);
}

@end
